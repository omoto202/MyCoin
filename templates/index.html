<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>MyCoin Wallet</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.6.1/elliptic.min.js"></script>
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<style>
body { font-family: Arial, sans-serif; padding: 20px; background: #f7f7f7; }
input { padding: 6px; margin: 6px 0; width: 320px; }
button { padding: 6px 10px; margin: 4px; }
textarea { width: 100%; }
.block { background: #fff; padding: 12px; border-radius: 6px; margin-bottom: 12px; }
#history { white-space: pre-wrap; background:#f9f9f9; padding:8px; border-radius:4px; }
</style>
</head>
<body>
<h1>MyCoin Wallet</h1>

<div class="block">
  <h2>鍵管理</h2>
  <button id="genBtn">鍵ペア生成</button>
  <button id="resetBtn">鍵ペアリセット</button>
  <div id="keys">鍵がありません。</div>
</div>

<div class="block">
  <h2>送金</h2>
  <form id="txForm">
    <input name="recipient" placeholder="受信者の公開鍵 (hex)" required><br>
    <input name="amount" placeholder="金額 (例: 1.2345)" required><br>
    <button type="submit">送信</button>
  </form>
  <div id="txResult"></div>
</div>

<div class="block">
  <h2>残高確認</h2>
  <form id="balanceForm">
    <input name="address" placeholder="アドレスを入力（空で自分の公開鍵）"><br>
    <button type="submit">残高取得</button>
  </form>
  <div id="balance">残高: -</div>
</div>

<div class="block">
  <h2>チェーン全体</h2>
  <button id="loadChainBtn">全履歴を表示</button>
  <div id="history"></div>
</div>

<div class="block">
  <h2>マイニング</h2>
  <button id="mineBtn">マイニング開始</button>
  <div id="mineStatus"></div>
</div>

<script>
// elliptic setup
const ec = new elliptic.ec('secp256k1');
const socket = io();

// helper: store/load keys
function saveKeys(pub, priv) {
  localStorage.setItem('publicKey', pub);
  localStorage.setItem('privateKey', priv);
}
function loadKeys() {
  return {
    publicKey: localStorage.getItem('publicKey'),
    privateKey: localStorage.getItem('privateKey')
  };
}
function updateKeysUI() {
  const { publicKey, privateKey } = loadKeys();
  const el = document.getElementById('keys');
  if(publicKey && privateKey) {
    el.innerHTML = `<div><b>公開鍵</b><br><textarea rows="2">${publicKey}</textarea></div>
                    <div><b>秘密鍵</b><br><textarea rows="2">${privateKey}</textarea></div>`;
  } else {
    el.innerText = "鍵がありません。生成してください。";
  }
}

// generate keys
document.getElementById('genBtn').onclick = function(){
  const key = ec.genKeyPair();
  const priv = key.getPrivate('hex');
  const pub = key.getPublic('hex'); // uncompressed hex starting with '04'
  saveKeys(pub, priv);
  updateKeysUI();
  updateBalance(); loadChain();
};

// reset keys
document.getElementById('resetBtn').onclick = function(){
  localStorage.removeItem('publicKey');
  localStorage.removeItem('privateKey');
  updateKeysUI();
  document.getElementById('balance').innerText = "残高: -";
  document.getElementById('history').innerText = "";
};

// transaction submit (署名付き、amount を 8桁固定で送る)
document.getElementById('txForm').onsubmit = async function(e){
  e.preventDefault();
  const { publicKey, privateKey } = loadKeys();
  if(!publicKey || !privateKey) { alert("鍵を生成してください"); return; }

  const recipient = e.target.recipient.value.trim();
  const amountRaw = parseFloat(e.target.amount.value);
  if(!recipient || isNaN(amountRaw)) { alert("正しい入力をしてください"); return; }
  const amount = amountRaw.toFixed(8);

  // message format MUST match server: sender->recipient:amount (8 decimals)
  const message = `${publicKey}->${recipient}:${amount}`;
  const key = ec.keyFromPrivate(privateKey, 'hex');
  const signature = key.sign(message).toDER('hex');

  const payload = { sender: publicKey, recipient, amount, signature };

  const res = await fetch('/transactions/new', {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify(payload)
  });

  const text = await res.text();
  document.getElementById('txResult').innerText = text;
};

// balance form
document.getElementById('balanceForm').onsubmit = async function(e){
  e.preventDefault();
  let address = e.target.address.value.trim();
  if(!address) {
    address = loadKeys().publicKey;
    if(!address) { alert("アドレスが指定されていません"); return; }
  }
  await updateBalance(address);
};

async function updateBalance(address){
  const addr = address || loadKeys().publicKey;
  if(!addr) { document.getElementById('balance').innerText = "残高: -"; return; }
  const res = await fetch('/balance/' + addr);
  const j = await res.json();
  document.getElementById('balance').innerText = `残高: ${j.balance}`;
}

// load full chain
document.getElementById('loadChainBtn').onclick = loadChain;
async function loadChain(){
  const res = await fetch('/chain');
  const j = await res.json();
  let out = "";
  j.chain.forEach((block, idx) => {
    out += `Block #${idx}\n`;
    out += `Timestamp: ${new Date(block.timestamp * 1000).toLocaleString()}\n`;
    out += `Hash: ${block.hash}\n`;
    out += `Prev: ${block.prev_hash}\n`;
    out += `Transactions:\n`;
    if(!block.transactions || block.transactions.length === 0) {
      out += "  (none)\n";
    } else {
      block.transactions.forEach(tx => {
        out += `  ${tx.sender} -> ${tx.recipient} : ${tx.amount}`;
        if(tx.signature) out += ` (sig:${tx.signature.slice(0,12)}...)`;
        out += "\n";
      });
    }
    out += "\n-------------------------\n";
  });
  document.getElementById('history').innerText = out;
}

// mining (use local publicKey automatically, send as POST, show status)
let mining = false;
document.getElementById('mineBtn').onclick = async function(){
  if(mining) return;
  const { publicKey } = loadKeys();
  if(!publicKey) { alert("鍵を生成してください"); return; }

  mining = true;
  const statusEl = document.getElementById('mineStatus');
  statusEl.innerText = "マイニング中...";

  try {
    const res = await fetch('/mine', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ miner: publicKey })
    });
    if(!res.ok){
      const txt = await res.text();
      statusEl.innerText = "Error: " + txt;
    } else {
      const j = await res.json();
      statusEl.innerText = `Block mined: ${j.block_hash} (miner: ${j.miner})`;
      // update local view
      await updateBalance(j.miner);
      await loadChain();
    }
  } catch (err) {
    statusEl.innerText = "Error: " + err;
  } finally {
    mining = false;
    setTimeout(()=>{ document.getElementById('mineStatus').innerText = ""; }, 4000);
  }
};

// Socket.IO updates
socket.on('connect', ()=>{ /* connected */ });
socket.on('update', async (data) => {
  // update balance for current user and reload chain
  const pub = loadKeys().publicKey;
  if(pub) await updateBalance(pub);
  else await updateBalance();
  await loadChain();
});

// initial UI
updateKeysUI();
updateBalance();
loadChain();

// fallback polling
setInterval(()=>{ loadChain(); }, 15000);
</script>
</body>
</html>
